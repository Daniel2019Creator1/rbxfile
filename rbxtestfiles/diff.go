package main

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"

	"github.com/anaminus/but"
)

type jType byte

const (
	jNull jType = iota
	jBool
	jNumber
	jString
	jArray
	jObject
)

func (t jType) String() string {
	switch t {
	case jNull:
		return "null"
	case jBool:
		return "bool"
	case jNumber:
		return "number"
	case jString:
		return "string"
	case jArray:
		return "array"
	case jObject:
		return "object"
	}
	return "invalid"
}

type jEmpty struct{}

func intlen(i int) int {
	n := 1
	if i >= 100000000 {
		n += 8
		i /= 100000000
	}
	if i >= 10000 {
		n += 4
		i /= 10000
	}
	if i >= 100 {
		n += 2
		i /= 100
	}
	if i >= 10 {
		n += 1
	}
	return n
}

type diff struct {
	path string
	typ  string
	x    string
	y    string
}

func (d diff) String() string {
	var s string
	if d.path != "" {
		s += d.path + ": "
	}
	if d.y == "" {
		return s + d.typ + ": " + d.x
	}
	return s + d.typ + ":\n\t" + d.x + "\n\t" + d.y + "\n"
}

// comparer compares two values generated by json.Unmarshal.
type comparer struct {
	diffs []diff
	stack []string
}

func (c *comparer) push(s string, i int) {
	if i >= 0 {
		c.stack = append(c.stack, "["+strconv.Itoa(i)+"]")
		return
	}
	if len(s) == 0 {
		c.stack = append(c.stack, "[\"\"]")
		return
	}
	if q := fmt.Sprintf("%q", s); len(q)-2 != len(s) {
		c.stack = append(c.stack, "["+q+"]")
		return
	}
	c.stack = append(c.stack, s)
}

func (c *comparer) pop() {
	c.stack = c.stack[:len(c.stack)-1]
}

func (c *comparer) path() string {
	if len(c.stack) == 0 {
		return ""
	}
	var path string
	var buf strings.Builder
	buf.WriteString(c.stack[0])
	for i := 1; i < len(c.stack); i++ {
		if c.stack[i][0] != '[' {
			buf.WriteByte('.')
		}
		buf.WriteString(c.stack[i])
	}
	path = buf.String()
	return path
}

func (c *comparer) appendType(x, y jType) {
	c.diffs = append(c.diffs, diff{
		path: c.path(),
		typ:  "type",
		x:    x.String() + " != " + y.String(),
	})
}

func (c *comparer) appendLen(typ string, i, j int, x, y interface{}) {
	c.diffs = append(c.diffs, diff{
		path: c.path(),
		typ:  typ + " length",
		x:    strconv.Itoa(i) + " != " + strconv.Itoa(j),
	})
}

func (c *comparer) appendValue(x, y interface{}) {
	c.diffs = append(c.diffs, diff{
		path: c.path(),
		typ:  "value",
		x:    fmt.Sprintf("%v", x),
		y:    fmt.Sprintf("%v", y),
	})
}

func (c *comparer) bytesToLines(x []interface{}) []string {
	lines := []string{}
	line := ""
	n := 0
	size := intlen(len(x))
	for i, v := range x {
		if i > 0 && i%16 == 0 {
			lines = append(lines, fmt.Sprintf("%0*d: ", size, n)+line[1:])
			n = i
			line = ""
		}
		line += fmt.Sprintf(" %02X", byte(v.(float64)))
	}
	if line != "" {
		lines = append(lines, fmt.Sprintf("%0*d: ", size, n)+line[1:])
	}
	return lines
}

func (c *comparer) diffBytes(x, y []interface{}) string {
	chunks := DiffChunks(c.bytesToLines(x), c.bytesToLines(y))
	var buf strings.Builder
	for _, c := range chunks {
		for _, line := range c.Added {
			fmt.Fprintf(&buf, "\t+%s\n", line)
		}
		for _, line := range c.Deleted {
			fmt.Fprintf(&buf, "\t-%s\n", line)
		}
		for _, line := range c.Equal {
			fmt.Fprintf(&buf, "\t %s\n", line)
		}
	}
	return "\n" + buf.String()
}

func (c *comparer) appendBytes(x, y []interface{}) {
	switch {
	case x == nil:
		c.diffs = append(c.diffs, diff{
			path: c.path(),
			typ:  "bytes: extraneous field",
			x:    c.diffBytes(nil, y),
		})
	case y == nil:
		c.diffs = append(c.diffs, diff{
			path: c.path(),
			typ:  "bytes: missing field",
			x:    c.diffBytes(x, nil),
		})
	}
	c.diffs = append(c.diffs, diff{
		path: c.path(),
		typ:  "bytes",
		x:    c.diffBytes(x, y),
	})
}

func (*comparer) typeof(x interface{}) jType {
	switch x.(type) {
	case nil:
		return jNull
	case bool:
		return jBool
	case float64, json.Number:
		return jNumber
	case string:
		return jString
	case []interface{}:
		return jArray
	case map[string]interface{}:
		return jObject
	}
	panic("unexpected type")
}

func (*comparer) isbytes(x []interface{}) bool {
	if len(x) == 0 {
		return false
	}
	for _, v := range x {
		switch v := v.(type) {
		case float64:
			if float64(int(v)) != v || v < 0 || v > 255 {
				return false
			}
		case json.Number:
			f, _ := v.Float64()
			if float64(int(f)) != f || f < 0 || f > 255 {
				return false
			}
		default:
			return false
		}
	}
	return true
}

func (c *comparer) compare(x, y interface{}) {
	if tx, ty := c.typeof(x), c.typeof(y); tx != ty {
		c.appendType(tx, ty)
		return
	}

	// Nil only has one value, so comparing it is already handled by checking
	// the type.

	switch x := x.(type) {
	case bool:
		if y.(bool) != x {
			c.appendValue(x, y)
			return
		}
	case float64:
		if y.(float64) != x {
			c.appendValue(x, y)
			return
		}
	case json.Number:
		xf, _ := x.Float64()
		yf, _ := y.(json.Number).Float64()
		if yf != xf {
			c.appendValue(xf, yf)
			return
		}
	case string:
		if y.(string) != x {
			c.appendValue(x, y)
			return
		}
	case []interface{}:
		y := y.([]interface{})
		if c.isbytes(x) && c.isbytes(y) {
			if j, i := len(y), len(x); j != i {
				c.appendLen("bytes", i, j, x, y)
				return
			}
			for i, b := range x {
				if y[i] != b {
					c.appendBytes(x, y)
					return
				}
			}
		}
		if j, i := len(y), len(x); j != i {
			c.appendLen("array", i, j, x, y)
			return
		}
		for i, v := range x {
			c.push("", i)
			c.compare(v, y[i])
			c.pop()
		}
	case map[string]interface{}:
		y := y.(map[string]interface{})
		if j, i := len(y), len(x); j != i {
			c.appendLen("object", i, j, x, y)
			return
		}
		for k, xv := range x {
			c.push(k, -1)
			yv, ok := y[k]
			if !ok {
				if bv, ok := xv.([]interface{}); ok && c.isbytes(bv) {
					c.appendBytes(bv, nil)
					continue
				}
				c.appendValue(xv, jEmpty{})
				continue
			}
			c.compare(xv, yv)
			c.pop()
		}
		for k, yv := range y {
			c.push(k, -1)
			if _, ok := x[k]; !ok {
				if bv, ok := yv.([]interface{}); ok && c.isbytes(bv) {
					c.appendBytes(nil, bv)
					continue
				}
				c.appendValue(jEmpty{}, yv)
			}
			c.pop()
		}
	}
	return
}

func setLine(buf []byte, l int, op byte) []byte {
	if l < 0 {
		for i := range buf {
			buf[i] = '.'
		}
		return buf
	}
	n := len(buf) - 1 - intlen(l)
	for i := 0; i < n; i++ {
		buf[i] = ' '
	}
	strconv.AppendUint(buf[n:n], uint64(l), 10)
	buf[len(buf)-1] = op
	return buf
}

// func diffGolden(input string, curr, spec []byte) error {
// 	var icurr, ispec interface{}
// 	if err := json.Unmarshal(curr, &icurr); err != nil {
// 		return fmt.Errorf("decode current: %w", err)
// 	}
// 	if err := json.Unmarshal(spec, &ispec); err != nil {
// 		return fmt.Errorf("decode specification: %w", err)
// 	}
// 	var c comparer
// 	c.compare(icurr, ispec)
// 	for _, diff := range c.diffs {
// 		fmt.Println(diff.String())
// 	}
// 	return nil
// }

func diffGolden(input string, context int, curr, spec []byte) error {
	var icurr, ispec interface{}
	if but.IfError(json.Unmarshal(curr, &icurr), "skipping comparison: current:") {
		goto lineDiff
	}
	if but.IfError(json.Unmarshal(spec, &ispec), "skipping comparison: specification") {
		goto lineDiff
	}
	{
		var c comparer
		c.compare(icurr, ispec)
		if len(c.diffs) == 0 {
			return nil
		}
	}

lineDiff:
	currLines := strings.Split(string(curr), "\n")
	specLines := strings.Split(string(spec), "\n")
	chunks := DiffChunks(currLines, specLines)

	type lineData struct {
		line int
		op   byte
		text string
	}

	var lines []lineData
	{
		var prev []string
		var prevLine int
		for _, c := range chunks {
			if len(c.Added)+len(c.Deleted) == 0 {
				i := len(c.Equal) - context
				if i < 0 {
					i = 0
				}
				prev = c.Equal[i:]
				prevLine = c.EqualLine + i
				continue
			}
			for i, line := range prev {
				lines = append(lines, lineData{
					line: prevLine + i,
					op:   ' ',
					text: line,
				})
			}
			for i, line := range c.Deleted {
				lines = append(lines, lineData{
					line: c.DeletedLine + i,
					op:   '-',
					text: line,
				})
			}
			for i, line := range c.Added {
				lines = append(lines, lineData{
					line: c.AddedLine + i,
					op:   '+',
					text: line,
				})
			}
			prev = nil
			for i, line := range c.Equal {
				if i < context {
					lines = append(lines, lineData{
						line: c.EqualLine + i,
						op:   ' ',
						text: line,
					})
					continue
				}
				if j := len(c.Equal) - context; i < j {
					i = j
				}
				prev = c.Equal[i:]
				prevLine = c.EqualLine + i
				break
			}
		}
	}

	if len(lines) == 0 {
		return nil
	}
	// sort.Slice(lines, func(i, j int) bool {
	// 	if lines[i].line == lines[j].line {
	// 		return lines[i].op > lines[j].op
	// 	}
	// 	return lines[i].line < lines[j].line
	// })

	var max int
	for _, line := range lines {
		if line.line > max {
			max = line.line
		}
	}

	buf := make([]byte, intlen(max)+1)

	var b strings.Builder
	b.WriteString("--- ")
	b.WriteString(input)
	b.WriteString(".golden\n")
	b.WriteString("+++ ")
	b.WriteString(input)
	b.WriteByte('\n')
	var prev lineData
	for _, line := range lines {
		if color {
			switch line.op {
			case '+':
				b.WriteString("\x1b[33m")
			case '-':
				b.WriteString("\x1b[34m")
			default:
				b.WriteString("\x1b[0m")
			}
		}
		if line.op == ' ' && prev.op == ' ' && line.line-1 != prev.line {
			b.Write(setLine(buf[:len(buf)-1], -1, 0))
			b.WriteByte('\n')
		}
		b.Write(setLine(buf, line.line, line.op))
		b.WriteString(line.text)
		b.WriteByte('\n')
		prev = line
	}
	if color {
		b.WriteString("\x1b[0m")
	}
	fmt.Println(b.String())
	return nil
}
